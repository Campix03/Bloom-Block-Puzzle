<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bloom Block Puzzle</title>
    <link rel="manifest" href="./manifest.json" />
    <meta name="theme-color" content="#3b82f6" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7.24.0/babel.min.js"></script>
    <style>
      html, body, #root {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.1.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
    "react/": "https://aistudiocdn.com/react@^19.1.1/"
  }
}
</script>
</head>
<body>
    <noscript>Necesitas habilitar JavaScript para jugar este juego.</noscript>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
// BUNDLED CODE - ALL .TSX and .TS FILES ARE MERGED HERE

// --- From types.ts ---
const Types = {}; // Placeholder for types if needed in JS

// --- From constants.ts ---
const COLS = 10;
const ROWS = 10;
const CELL_SIZE = 30;
const FLASH_DURATION = 150;
const INITIAL_SHUFFLES = 3;

const COLORS = [
    '#66b2ff', '#ff8585', '#66ff99', '#ffcc66', '#a366ff', '#4dffc0', '#ff66b2', '#8c95ff'
];

const DETONABLE_COLOR = '#ffea00';

const PIECES = [
    [[1]], [[1, 1]], [[1], [1]], [[1, 1, 1]], [[1], [1], [1]],
    [[1, 1, 1, 1]], [[1], [1], [1], [1]], [[1, 1], [1, 1]],
    [[1, 1, 1], [1, 1, 1], [1, 1, 1]], [[1, 0], [1, 0], [1, 1]],
    [[1, 1, 1], [1, 0, 0]], [[0, 1], [0, 1], [1, 1]], [[1, 1, 1], [0, 0, 1]],
    [[0, 1], [0, 1], [1, 1]], [[1, 1, 1], [0, 0, 1]], [[1, 0], [1, 0], [1, 1]],
    [[1, 1, 1], [1, 0, 0]], [[0, 1, 0], [1, 1, 1]], [[1, 0], [1, 1], [1, 0]],
    [[1, 1, 1], [0, 1, 0]], [[0, 1], [1, 1], [0, 1]], [[0, 1, 1], [1, 1, 0]],
    [[1, 1, 0], [0, 1, 1]],
];

// --- From hooks/useGameLogic.ts ---
const useGameLogic = () => {
  const { useState, useEffect, useCallback } = React;
  const [grid, setGrid] = useState(() => Array.from({ length: ROWS }, () => Array(COLS).fill(0)));
  const [pieces, setPieces] = useState([]);
  const [score, setScore] = useState(0);
  const [highScore, setHighScore] = useState(() => Number(localStorage.getItem('bloomBlockHighScore') || 0));
  const [shufflesLeft, setShufflesLeft] = useState(INITIAL_SHUFFLES);
  const [detonableRows, setDetonableRows] = useState([]);
  const [detonableCols, setDetonableCols] = useState([]);
  const [isGameOver, setIsGameOver] = useState(false);
  const [message, setMessage] = useState(null);

  const updateScore = useCallback((points) => {
    setScore(prev => {
      const newScore = prev + points;
      if (newScore > highScore) {
        setHighScore(newScore);
        localStorage.setItem('bloomBlockHighScore', String(newScore));
      }
      return newScore;
    });
  }, [highScore]);

  const canPlace = useCallback((piece, startRow, startCol, currentGrid) => {
    for (let r = 0; r < piece.shape.length; r++) {
      for (let c = 0; c < piece.shape[r].length; c++) {
        if (piece.shape[r][c]) {
          const boardRow = startRow + r;
          const boardCol = startCol + c;
          if (boardRow >= ROWS || boardCol >= COLS || boardRow < 0 || boardCol < 0 || currentGrid[boardRow][boardCol] !== 0) {
            return false;
          }
        }
      }
    }
    return true;
  }, []);

  const checkIfPieceCanBePlaced = useCallback((piece, currentGrid) => {
    for (let r = 0; r <= ROWS - piece.shape.length; r++) {
      for (let c = 0; c <= COLS - piece.shape[0].length; c++) {
        if (canPlace(piece, r, c, currentGrid)) {
          return true;
        }
      }
    }
    return false;
  }, [canPlace]);

  const generateNewPiece = useCallback(() => {
    const randomPieceShape = PIECES[Math.floor(Math.random() * PIECES.length)];
    const colorIndex = Math.floor(Math.random() * COLORS.length);
    return { shape: randomPieceShape, color: COLORS[colorIndex], colorIndex: colorIndex + 1 };
  }, []);

  const initializePieces = useCallback(() => {
    setPieces(Array.from({ length: 3 }, generateNewPiece));
  }, [generateNewPiece]);

  const checkAndMarkLines = useCallback((currentGrid) => {
    const newDetonableRows = [];
    const newDetonableCols = [];
    for (let r = 0; r < ROWS; r++) {
      if (currentGrid[r].every(cell => cell !== 0)) newDetonableRows.push(r);
    }
    for (let c = 0; c < COLS; c++) {
      if (currentGrid.every(row => row[c] !== 0)) newDetonableCols.push(c);
    }
    setDetonableRows(newDetonableRows);
    setDetonableCols(newDetonableCols);
  }, []);

  const placePiece = useCallback((piece, startRow, startCol, pieceIndex) => {
    const newGrid = grid.map(row => [...row]);
    let points = 0;
    for (let r = 0; r < piece.shape.length; r++) {
      for (let c = 0; c < piece.shape[r].length; c++) {
        if (piece.shape[r][c]) {
          newGrid[startRow + r][startCol + c] = piece.colorIndex;
          points++;
        }
      }
    }
    setGrid(newGrid);
    updateScore(points);
    let newPieces = pieces.filter((_, index) => index !== pieceIndex);
    if (newPieces.length === 0) {
        newPieces = Array.from({ length: 3 }, generateNewPiece);
    }
    setPieces(newPieces);
    checkAndMarkLines(newGrid);
  }, [grid, pieces, updateScore, generateNewPiece, checkAndMarkLines]);

  const detonateLines = useCallback(() => {
    const linesCleared = detonableRows.length + detonableCols.length;
    if (linesCleared === 0) {
      setMessage({ title: 'Sin l√≠neas listas', text: 'Coloca un bloque para completar una l√≠nea y marcarla para la detonaci√≥n.' });
      return;
    }
    const newGrid = grid.map(row => [...row]);
    detonableRows.forEach(r => newGrid[r].fill(0));
    detonableCols.forEach(c => newGrid.forEach(row => (row[c] = 0)));
    setGrid(newGrid);
    updateScore(linesCleared * 10);
    setDetonableRows([]);
    setDetonableCols([]);
  }, [grid, detonableRows, detonableCols, updateScore]);
  
  const shufflePieces = useCallback(() => {
      if (shufflesLeft > 0) {
          setShufflesLeft(prev => prev - 1);
          initializePieces();
      }
  }, [shufflesLeft, initializePieces]);

  const restartGame = useCallback(() => {
    setGrid(Array.from({ length: ROWS }, () => Array(COLS).fill(0)));
    setScore(0);
    setShufflesLeft(INITIAL_SHUFFLES);
    setDetonableRows([]);
    setDetonableCols([]);
    setIsGameOver(false);
    setMessage(null);
    initializePieces();
  }, [initializePieces]);

  useEffect(() => {
    const hasPossibleMoves = pieces.some(piece => checkIfPieceCanBePlaced(piece, grid));
    if (!hasPossibleMoves && shufflesLeft === 0 && pieces.length > 0) {
      setIsGameOver(true);
      setMessage({ title: 'Fin del juego', text: `Tu puntuaci√≥n final es: ${score}. Te has quedado sin movimientos.` });
    }
  }, [pieces, grid, shufflesLeft, score, checkIfPieceCanBePlaced]);
  
  useEffect(() => {
    initializePieces();
  }, []);

  return { grid, pieces, score, highScore, shufflesLeft, detonableRows, detonableCols, isGameOver, message, placePiece, detonateLines, shufflePieces, restartGame, canPlace, checkIfPieceCanBePlaced, setMessage };
};


// --- From components/MessageBox.tsx ---
const MessageBox = ({ title, text, buttonText = 'Cerrar', onClose, isButtonDisabled = false }) => {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
      <div className="flex flex-col items-center gap-5 bg-gradient-to-br from-indigo-800 to-indigo-900 border-2 border-cyan-400 rounded-2xl shadow-2xl p-8 max-w-md w-full text-center">
        <h2 className="text-4xl font-bold text-cyan-300 drop-shadow-[0_0_8px_#67e8f9]">{title}</h2>
        <p className="text-lg text-gray-200">{text}</p>
        <button
          onClick={onClose}
          disabled={isButtonDisabled}
          className="mt-4 py-2 px-6 bg-pink-500 text-white rounded-lg font-bold transition-colors duration-200 hover:bg-pink-600 disabled:bg-gray-600 disabled:cursor-not-allowed"
        >
          {buttonText.toUpperCase()}
        </button>
      </div>
    </div>
  );
};


// --- From components/Controls.tsx ---
const ActionButton = (props) => (
  <button
    {...props}
    className="py-2 px-4 bg-blue-600 text-white rounded-xl font-bold uppercase shadow-md transition-all duration-200 hover:enabled:bg-blue-700 hover:enabled:transform hover:enabled:-translate-y-0.5 disabled:bg-gray-600 disabled:cursor-not-allowed"
  />
);
const Controls = ({ onDetonate, onShuffle, shufflesLeft, isGameOver }) => {
  return (
    <div className="flex gap-2 justify-center mt-5 w-full flex-wrap">
      <ActionButton onClick={onDetonate} disabled={isGameOver}>ELIMINAR L√çNEA</ActionButton>
      <ActionButton onClick={onShuffle} disabled={isGameOver || shufflesLeft <= 0}>
        {`BARAJAR (${shufflesLeft})`}
      </ActionButton>
    </div>
  );
};


// --- From components/InfoPanel.tsx ---
const InfoPanel = ({ score, highScore }) => {
  return (
    <div className="flex justify-between items-center w-full gap-2">
      <div className="flex items-center gap-2 bg-black bg-opacity-25 rounded-xl p-2 px-4 font-bold text-white">
        <span className="text-2xl" role="img" aria-label="crown">üëë</span>
        <span className="text-xl">{highScore}</span>
      </div>
      <div className="bg-black bg-opacity-25 rounded-xl p-2 text-center flex-grow">
        <div className="text-sm text-gray-200">PUNTOS</div>
        <div className="text-4xl font-bold text-white drop-shadow-[0_0_5px_rgba(255,255,255,0.7)]">{score}</div>
      </div>
    </div>
  );
};


// --- From components/PiecePreview.tsx ---
const PiecePreview = ({ piece, onDragStart, canBePlaced = true, isHidden = false }) => {
  const { useRef, useEffect } = React;
  const canvasRef = useRef(null);
  const pieceWidth = piece.shape[0].length * CELL_SIZE;
  const pieceHeight = piece.shape.length * CELL_SIZE;

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = piece.color;
    for (let r = 0; r < piece.shape.length; r++) {
      for (let c = 0; c < piece.shape[r].length; c++) {
        if (piece.shape[r][c]) {
          const x = c * CELL_SIZE, y = r * CELL_SIZE, w = CELL_SIZE, h = CELL_SIZE, rad = 8;
          ctx.beginPath();
          ctx.moveTo(x + rad, y);
          ctx.lineTo(x + w - rad, y);
          ctx.quadraticCurveTo(x + w, y, x + w, y + rad);
          ctx.lineTo(x + w, y + h - rad);
          ctx.quadraticCurveTo(x + w, y + h, x + w - rad, y + h);
          ctx.lineTo(x + rad, y + h);
          ctx.quadraticCurveTo(x, y + h, x, y + h - rad);
          ctx.lineTo(x, y + rad);
          ctx.quadraticCurveTo(x, y, x + rad, y);
          ctx.closePath();
          ctx.fill();
        }
      }
    }
  }, [piece, pieceHeight, pieceWidth]);

  const classes = `cursor-grab border-2 border-transparent rounded-lg transition-transform duration-200 ${canBePlaced ? 'hover:scale-110 hover:border-[#66ff99] hover:shadow-lg hover:shadow-[#66ff99]/50' : 'opacity-50 cursor-not-allowed'}`;

  return (
    <div className={classes} style={{ visibility: isHidden ? 'hidden' : 'visible' }} onMouseDown={onDragStart} onTouchStart={onDragStart}>
      <canvas ref={canvasRef} width={pieceWidth} height={pieceHeight} />
    </div>
  );
};

// --- From components/GameBoard.tsx ---
const GameBoard = React.forwardRef(({ grid, detonableRows, detonableCols, ghostPiece, ghostPosition }, ref) => {
  const { useRef, useEffect } = React;
  const internalRef = useRef(null);
  const canvasRef = (ref || internalRef);

  const drawCell = (ctx, x, y, width, height, radius) => {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const cellValue = grid[r][c];
        ctx.fillStyle = cellValue > 0 ? COLORS[cellValue - 1] : 'rgba(0, 0, 0, 0.2)';
        drawCell(ctx, c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE, 8);
        if (cellValue > 0) {
            ctx.strokeStyle = 'rgba(0,0,0,0.4)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
      }
    }
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = DETONABLE_COLOR;
    detonableRows.forEach(r => {
      for (let c = 0; c < COLS; c++) drawCell(ctx, c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE, 8);
    });
    detonableCols.forEach(c => {
      for (let r = 0; r < ROWS; r++) drawCell(ctx, c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE, 8);
    });
    ctx.globalAlpha = 1.0;
    if (ghostPiece && ghostPosition) {
        const { row: startRow, col: startCol } = ghostPosition;
        ctx.fillStyle = ghostPiece.color;
        for (let r = 0; r < ghostPiece.shape.length; r++) {
            for (let c = 0; c < ghostPiece.shape[r].length; c++) {
                if (ghostPiece.shape[r][c]) {
                    const x = (startCol + c) * CELL_SIZE;
                    const y = (startRow + r) * CELL_SIZE;
                    drawCell(ctx, x, y, CELL_SIZE, CELL_SIZE, 8);
                    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }
    }
  }, [grid, detonableRows, detonableCols, ghostPiece, ghostPosition, canvasRef]);

  return (
    <canvas ref={canvasRef} width={COLS * CELL_SIZE} height={ROWS * CELL_SIZE} className="bg-black bg-opacity-20 rounded-xl shadow-inner" />
  );
});


// --- From components/Game.tsx ---
const Game = ({ onGoHome }) => {
  const { useState, useRef, useCallback, useEffect } = React;
  const { grid, pieces, score, highScore, shufflesLeft, detonableRows, detonableCols, isGameOver, message, placePiece, detonateLines, shufflePieces, restartGame, canPlace, checkIfPieceCanBePlaced, setMessage } = useGameLogic();
  const [draggedItem, setDraggedItem] = useState(null);
  const [ghostPosition, setGhostPosition] = useState(null);
  const gameContainerRef = useRef(null);
  const canvasRef = useRef(null);

  const handleDragStart = (piece, index, e) => {
    if (isGameOver || !checkIfPieceCanBePlaced(piece, grid)) return;
    setDraggedItem({ piece, index });
  };
  
  const handleDragMove = useCallback((e) => {
    if (!draggedItem) return;
    const isTouchEvent = 'touches' in e;
    const clientX = isTouchEvent ? e.touches[0].clientX : e.clientX;
    const clientY = isTouchEvent ? e.touches[0].clientY : e.clientY;
    if (canvasRef.current) {
        const rect = canvasRef.current.getBoundingClientRect();
        const mouseX = clientX - rect.left;
        const mouseY = clientY - rect.top;
        const col = Math.floor(mouseX / 30);
        const row = Math.floor(mouseY / 30);
        if (canPlace(draggedItem.piece, row, col, grid)) {
            setGhostPosition({ row, col });
        } else {
            setGhostPosition(null);
        }
    }
  }, [draggedItem, grid, canPlace]);
  
  const handleDragEnd = useCallback(() => {
    if (!draggedItem || !ghostPosition) {
        setDraggedItem(null);
        setGhostPosition(null);
        return;
    }
    placePiece(draggedItem.piece, ghostPosition.row, ghostPosition.col, draggedItem.index);
    setDraggedItem(null);
    setGhostPosition(null);
  }, [draggedItem, ghostPosition, placePiece]);

  const handleMessageClose = () => {
    if (isGameOver) restartGame();
    else setMessage(null);
  };

  useEffect(() => {
    if (draggedItem) {
      window.addEventListener('mousemove', handleDragMove);
      window.addEventListener('touchmove', handleDragMove);
      window.addEventListener('mouseup', handleDragEnd);
      window.addEventListener('touchend', handleDragEnd);
    }
    return () => {
      window.removeEventListener('mousemove', handleDragMove);
      window.removeEventListener('touchmove', handleDragMove);
      window.removeEventListener('mouseup', handleDragEnd);
      window.removeEventListener('touchend', handleDragEnd);
    };
  }, [draggedItem, handleDragMove, handleDragEnd]);

  return (
    <>
      <div ref={gameContainerRef} className="relative flex flex-col items-center gap-5 p-5 bg-black bg-opacity-20 rounded-2xl shadow-lg max-w-lg w-11/12">
        <button onClick={onGoHome} className="absolute top-5 left-5 text-white hover:text-cyan-300 transition-colors duration-200 z-10" aria-label="Volver al inicio" title="Volver al inicio">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h7.5" />
          </svg>
        </button>
        <InfoPanel score={score} highScore={highScore} />
        <GameBoard ref={canvasRef} grid={grid} detonableRows={detonableRows} detonableCols={detonableCols} ghostPiece={draggedItem?.piece} ghostPosition={ghostPosition} />
        <div className="w-full">
          <h3 className="text-lg font-bold text-center mb-2 select-none">PR√ìXIMAS PIEZAS</h3>
          <div className="flex flex-row justify-center items-center gap-4 p-5 bg-black bg-opacity-20 rounded-2xl shadow-inner flex-wrap">
            {pieces.map((piece, index) => (
              <PiecePreview key={index} piece={piece} onDragStart={(e) => handleDragStart(piece, index, e)} canBePlaced={checkIfPieceCanBePlaced(piece, grid)} isHidden={draggedItem?.index === index} />
            ))}
          </div>
        </div>
        <Controls onDetonate={detonateLines} onShuffle={shufflePieces} shufflesLeft={shufflesLeft} isGameOver={isGameOver} />
      </div>
      {message && (<MessageBox title={message.title} text={message.text} onClose={handleMessageClose} buttonText={isGameOver ? 'VOLVER A JUGAR' : 'CERRAR'} />)}
    </>
  );
};


// --- From components/StartScreen.tsx ---
const StartScreen = ({ onStart, onShowRules, onShowAdventure }) => {
    const { useRef, useEffect, useState } = React;
    const [animatingPiece, setAnimatingPiece] = useState(null);
    const animCanvasRef = useRef(null);

    useEffect(() => {
      const selectNewPiece = () => {
        const randomPieceShape = PIECES[Math.floor(Math.random() * PIECES.length)];
        const colorIndex = Math.floor(Math.random() * COLORS.length);
        setAnimatingPiece({ shape: randomPieceShape, color: COLORS[colorIndex], colorIndex: colorIndex + 1 });
      };
      selectNewPiece();
      const intervalId = setInterval(selectNewPiece, 1500);
      return () => clearInterval(intervalId);
    }, []);
    
    useEffect(() => {
        if (!animatingPiece || !animCanvasRef.current) return;
        const canvas = animCanvasRef.current;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        const piece = animatingPiece.shape;
        const pieceWidth = piece[0].length * CELL_SIZE;
        const pieceHeight = piece.length * CELL_SIZE;
        const offsetX = (canvas.width - pieceWidth) / 2;
        const offsetY = (canvas.height - pieceHeight) / 2;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = animatingPiece.color;
        for (let r = 0; r < piece.length; r++) {
          for (let c = 0; c < piece[r].length; c++) {
            if (piece[r][c]) {
                const x = offsetX + c * CELL_SIZE, y = offsetY + r * CELL_SIZE, w = CELL_SIZE, h = CELL_SIZE, rad = 8;
                ctx.beginPath();
                ctx.moveTo(x + rad, y);
                ctx.lineTo(x + w - rad, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + rad);
                ctx.lineTo(x + w, y + h - rad);
                ctx.quadraticCurveTo(x + w, y + h, x + w - rad, y + h);
                ctx.lineTo(x + rad, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - rad);
                ctx.lineTo(x, y + rad);
                ctx.quadraticCurveTo(x, y, x + rad, y);
                ctx.closePath();
                ctx.fill();
            }
          }
        }
    }, [animatingPiece]);

  return (
    <div className="relative flex flex-col items-center justify-between text-center p-5 max-w-lg w-11/12 h-[80vh] min-h-[500px]">
      <button onClick={onShowRules} className="absolute top-4 left-4 w-10 h-10 rounded-full bg-black bg-opacity-25 flex items-center justify-center text-2xl font-bold text-white hover:bg-opacity-40 transition-all" aria-label="Mostrar reglas">?</button>
      <div className="flex-grow flex flex-col items-center justify-center">
        <div className="relative mb-8">
            <h1 className="text-6xl md:text-7xl font-extrabold tracking-tighter text-white drop-shadow-[0_4px_6px_rgba(0,0,0,0.4)]">BLOOM<br/>BLOCK</h1>
        </div>
        <canvas ref={animCanvasRef} width={CELL_SIZE * 5} height={CELL_SIZE * 5} className="mb-12" />
      </div>
      <div className="w-full flex flex-col gap-4 px-4">
        <button onClick={onStart} className="flex items-center justify-center gap-3 w-full py-4 px-8 bg-green-500 text-white rounded-xl font-bold text-2xl uppercase shadow-lg transition-all duration-200 hover:bg-green-600 hover:scale-105">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
          Cl√°sico
        </button>
        <button onClick={onShowAdventure} className="flex items-center justify-center gap-3 w-full py-4 px-8 bg-gray-700 text-gray-400 rounded-xl font-bold text-2xl uppercase shadow-lg cursor-not-allowed">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" /><path strokeLinecap="round" strokeLinejoin="round" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
          Aventura
        </button>
      </div>
    </div>
  );
};


// --- From App.tsx ---
function App() {
  const { useState, useCallback } = React;
  const [gameState, setGameState] = useState('start');
  const [isRulesVisible, setIsRulesVisible] = useState(false);
  const [isAdventureModalVisible, setIsAdventureModalVisible] = useState(false);

  const startGame = useCallback(() => setGameState('playing'), []);
  const goHome = useCallback(() => setGameState('start'), []);

  const backgroundClass = 'bg-gradient-to-br from-blue-500 to-indigo-600';
  const rulesText = `Las reglas son simples: arrastra las piezas al tablero para completar l√≠neas o columnas y ganar puntos. Si te quedas sin movimientos, puedes usar una de tus 3 barajas iniciales para obtener nuevas piezas. El bot√≥n de Eliminar L√≠nea es ilimitado, pero solo funciona cuando tienes al menos una l√≠nea completa en el tablero. ¬°√ösalo para despejar el espacio!`;

  return (
    <div className={`min-h-screen text-white flex flex-col items-center justify-center p-4 transition-colors duration-500 ${backgroundClass}`}>
      {gameState === 'start' && <StartScreen onStart={startGame} onShowRules={() => setIsRulesVisible(true)} onShowAdventure={() => setIsAdventureModalVisible(true)} />}
      {gameState === 'playing' && <Game onGoHome={goHome} />}
      {isRulesVisible && <MessageBox title="Reglas del Juego" text={rulesText} onClose={() => setIsRulesVisible(false)} buttonText="ENTENDIDO" />}
      {isAdventureModalVisible && <MessageBox title="Modo Aventura" text="¬°El modo Aventura llegar√° muy pronto! Prep√°rate para nuevos desaf√≠os." onClose={() => setIsAdventureModalVisible(false)} buttonText="OK" />}
    </div>
  );
}


// --- From index.tsx --- (Entry point)
document.addEventListener('DOMContentLoaded', () => {
    const rootElement = document.getElementById('root');
    if (!rootElement) {
        throw new Error("Could not find root element to mount to");
    }

    if ('serviceWorker' in navigator && !window.location.hostname.includes('usercontent.goog')) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js')
                .then(reg => console.log('Service Worker registered.', reg))
                .catch(err => console.error('Service Worker registration failed:', err));
        });
    }

    const root = ReactDOM.createRoot(rootElement);
    root.render(
        <React.StrictMode>
            <App />
        </React.StrictMode>
    );
});

    </script>
</body>
</html>
